/*
 * This file was autogenerated by the Lingua Franca Compiler.
 *
 * Source: file:/home/zekailin00/Desktop/PhysX/physx/snippets/snippethelloworld/lf-port/Hello.lf
 */

#include "Hello/PhysxDriver.hh"

using namespace reactor::operators;

  // private preamble
    #define PX_PHYSX_STATIC_LIB
    #include "SnippetRender.h"
    #include "SnippetCamera.h"
    #include "PxPhysicsAPI.h"
    #define PVD_HOST "127.0.0.1"
    using namespace physx;
  
    static PxDefaultAllocator	      	gAllocator;
    static PxDefaultErrorCallback	    gErrorCallback;
    static PxFoundation*	        	 	gFoundation = NULL;
    static PxPhysics*		           		gPhysics	= NULL;
    static PxDefaultCpuDispatcher*	  gDispatcher = NULL;
    static PxScene*			           		gScene		= NULL;
    static PxMaterial*		        		gMaterial	= NULL;
    static PxPvd*			            		gPvd = NULL;
  
    static Snippets::Camera* sCamera;
  
    static void stub() {}
  
    static void renderCallback()
    {
      // stepPhysics(true);
      gScene->simulate(1.0f/60.0f);
      gScene->fetchResults(true);
  
      Snippets::startRender(sCamera);
  
      PxScene* scene;
      PxGetPhysics().getScenes(&scene,1);
      PxU32 nbActors = scene->getNbActors(PxActorTypeFlag::eRIGID_DYNAMIC | PxActorTypeFlag::eRIGID_STATIC);
      if(nbActors)
      {
        std::vector<PxRigidActor*> actors(nbActors);
        scene->getActors(PxActorTypeFlag::eRIGID_DYNAMIC | PxActorTypeFlag::eRIGID_STATIC, reinterpret_cast<PxActor**>(&actors[0]), nbActors);
        Snippets::renderActors(&actors[0], static_cast<PxU32>(actors.size()), true);
      }
  
      Snippets::finishRender();
    }
  
    static void cleanupPhysics(bool /*interactive*/)
    {
      PX_RELEASE(gScene);
      PX_RELEASE(gDispatcher);
      PX_RELEASE(gPhysics);
      if(gPvd)
      {
        PxPvdTransport* transport = gPvd->getTransport();
        gPvd->release();	gPvd = NULL;
        PX_RELEASE(transport);
      }
      PX_RELEASE(gFoundation);
  
      printf("SnippetHelloWorld done.\n");
    }
  
    static void exitCallback(void)
    {
      delete sCamera;
      cleanupPhysics(true);
    }
  
    static PxRigidDynamic* createDynamic(const PxTransform& t, const PxGeometry& geometry, const PxVec3& velocity=PxVec3(0))
    {
      PxRigidDynamic* dynamic = PxCreateDynamic(*gPhysics, t, geometry, *gMaterial, 10.0f);
      dynamic->setAngularDamping(0.5f);
      dynamic->setLinearVelocity(velocity);
      gScene->addActor(*dynamic);
      return dynamic;
    }
  
    static void createStack(const PxTransform& t, PxU32 size, PxReal halfExtent)
    {
      PxShape* shape = gPhysics->createShape(PxBoxGeometry(halfExtent, halfExtent, halfExtent), *gMaterial);
      for(PxU32 i=0; i<size;i++)
      {
        for(PxU32 j=0;j<size-i;j++)
        {
          PxTransform localTm(PxVec3(PxReal(j*2) - PxReal(size-i), PxReal(i*2+1), 0) * halfExtent);
          PxRigidDynamic* body = gPhysics->createRigidDynamic(t.transform(localTm));
          body->attachShape(*shape);
          PxRigidBodyExt::updateMassAndInertia(*body, 10.0f);
          gScene->addActor(*body);
        }
      }
      shape->release();
    }
  
  static void keyPress(unsigned char key, const PxTransform& camera)
  {
  
  }

// outer constructor
PhysxDriver::PhysxDriver(const std::string& name, reactor::Environment* __lf_environment, Parameters&& __lf_parameters)
  : reactor::Reactor(name, __lf_environment)
  , __lf_inner(this, std::forward<Parameters>(__lf_parameters))
  //reactor instances
  // timers
  , step_size{"step_size", this, 16ms, reactor::Duration::zero()}
  // actions
  , keyboard_input{"keyboard_input", this}
  // reaction views
  
  
  
  
  
  
{
            
            
  // reaction views
  
  
  
  
  
  
}
PhysxDriver::PhysxDriver(const std::string& name, reactor::Reactor* __lf_container, Parameters&& __lf_parameters)
  : reactor::Reactor(name, __lf_container)
  , __lf_inner(this, std::forward<Parameters>(__lf_parameters))
  //reactor instances
  // timers
  , step_size{"step_size", this, 16ms, reactor::Duration::zero()}
  // actions
  , keyboard_input{"keyboard_input", this}
  // reaction views
  
  
  
  
  
  
{
            
            
  // reaction views
  
  
  
  
  
  
}

// inner constructor
PhysxDriver::Inner::Inner(::reactor::Reactor* reactor, Parameters&& parameters)
  : LFScope(reactor)
  , __lf_parameters(std::forward<Parameters>(parameters))
  // state variables
  , prompt_time(reactor::TimePoint::min())
  , count(0)
  , window_created(false)
  , stackZ(10)
{}

void PhysxDriver::assemble() {
  // reaction_1
  reaction_1.declare_trigger(&startup);
          
  reaction_1.declare_antidependency(&initalized);
  reaction_1.declare_schedulable_action(&keyboard_input);
          
  
  // reaction_2
  reaction_2.declare_trigger(&new_stack);
          
          
          
  
  // reaction_3
  reaction_3.declare_trigger(&fire);
          
          
          
  
  // reaction_4
  reaction_4.declare_trigger(&step_size);
          
          
          
  
  // reaction_5
  reaction_5.declare_trigger(&quit);
          
          
          
  
  // reaction_6
  reaction_6.declare_trigger(&shutdown);
          
          
  // connections
}

// methods


// reaction reaction_1

void PhysxDriver::Inner::reaction_1(
  [[maybe_unused]] const reactor::StartupTrigger& startup,
  reactor::Output<void>& initalized,
  reactor::PhysicalAction<unsigned char>& keyboard_input)  {
  sCamera = new Snippets::Camera(PxVec3(50.0f, 50.0f, 50.0f), PxVec3(-0.6f,-0.2f,-0.7f));
  
  gFoundation = PxCreateFoundation(PX_PHYSICS_VERSION, gAllocator, gErrorCallback);
  
  gPvd = PxCreatePvd(*gFoundation);
  PxPvdTransport* transport = PxDefaultPvdSocketTransportCreate(PVD_HOST, 5425, 10);
  gPvd->connect(*transport,PxPvdInstrumentationFlag::eALL);
  
  gPhysics = PxCreatePhysics(PX_PHYSICS_VERSION, *gFoundation, PxTolerancesScale(),true,gPvd);
  
  PxSceneDesc sceneDesc(gPhysics->getTolerancesScale());
  sceneDesc.gravity = PxVec3(0.0f, -9.81f, 0.0f);
  gDispatcher = PxDefaultCpuDispatcherCreate(2);
  sceneDesc.cpuDispatcher	= gDispatcher;
  sceneDesc.filterShader	= PxDefaultSimulationFilterShader;
  gScene = gPhysics->createScene(sceneDesc);
  
  PxPvdSceneClient* pvdClient = gScene->getScenePvdClient();
  if(pvdClient)
  {
    pvdClient->setScenePvdFlag(PxPvdSceneFlag::eTRANSMIT_CONSTRAINTS, true);
    pvdClient->setScenePvdFlag(PxPvdSceneFlag::eTRANSMIT_CONTACTS, true);
    pvdClient->setScenePvdFlag(PxPvdSceneFlag::eTRANSMIT_SCENEQUERIES, true);
  }
  gMaterial = gPhysics->createMaterial(0.5f, 0.5f, 0.6f);
  
  PxRigidStatic* groundPlane = PxCreatePlane(*gPhysics, PxPlane(0,1,0,0), *gMaterial);
  gScene->addActor(*groundPlane);
  
  for(PxU32 i=0;i<5;i++)
    createStack(PxTransform(PxVec3(0,0,stackZ-=10.0f)), 10, 2.0f);
  
  thread = std::thread([&]{
    Snippets::setupDefault("PhysX Snippet HelloWorld", sCamera, keyPress, renderCallback, exitCallback);
    glutMainLoop();
  });
  
  // glutMainLoop();
  // request the first prompt
  initalized.set();
}

// reaction reaction_2

void PhysxDriver::Inner::reaction_2([[maybe_unused]] const reactor::Input<void>& new_stack) {
  createStack(PxTransform(PxVec3(0,0,stackZ-=10.0f)), 10, 2.0f);
}

// reaction reaction_3

void PhysxDriver::Inner::reaction_3([[maybe_unused]] const reactor::Input<void>& fire) {
  PxTransform camera{};
  createDynamic(camera, PxSphereGeometry(3.0f), camera.rotate(PxVec3(0,0,-1))*200);
}

// reaction reaction_4

void PhysxDriver::Inner::reaction_4([[maybe_unused]] const reactor::Timer& step_size) {
  // if (window_created)
  // {
  //   std::cout << "Logical time is: " << get_logical_time() << std::endl;
  //   renderCallback();
  // }
  
  // gScene->simulate(1.0f/60.0f);
  // gScene->fetchResults(true);
}

// reaction reaction_5

void PhysxDriver::Inner::reaction_5([[maybe_unused]] const reactor::Input<void>& quit) {
  environment()->sync_shutdown();
}

// reaction reaction_6

void PhysxDriver::Inner::reaction_6([[maybe_unused]] const reactor::ShutdownTrigger& shutdown) {
  PX_RELEASE(gScene);
  PX_RELEASE(gDispatcher);
  PX_RELEASE(gPhysics);
  if(gPvd)
  {
    PxPvdTransport* transport = gPvd->getTransport();
    gPvd->release();	gPvd = NULL;
    PX_RELEASE(transport);
  }
  PX_RELEASE(gFoundation);
  
  printf("SnippetHelloWorld done.\n");
}

        
